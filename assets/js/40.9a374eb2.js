(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{391:function(v,_,l){"use strict";l.r(_);var i=l(25),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"权限修饰符"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#权限修饰符"}},[v._v("#")]),v._v(" 权限修饰符")]),v._v(" "),l("ul",[l("li",[v._v("public\n"),l("ul",[l("li",[v._v("使用对象：最广，类、接口、变量、方法")])])]),v._v(" "),l("li",[v._v("protected\n"),l("ul",[l("li",[v._v("使用对象：变量、方法 注意：不能修饰类（外部类）")])])]),v._v(" "),l("li",[v._v("default\n"),l("ul",[l("li",[v._v("使用对象：类、接口、变量、方法。（即缺省，什么也不写）")])])]),v._v(" "),l("li",[v._v("private\n"),l("ul",[l("li",[v._v("使用对象：变量、方法 注意：不能修饰类（外部类）")])])])]),v._v(" "),l("h2",{attrs:{id:"修饰符"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[v._v("#")]),v._v(" 修饰符")]),v._v(" "),l("ul",[l("li",[v._v("abstract\n"),l("ul",[l("li",[v._v("使用对象：类、接口、方法")])])]),v._v(" "),l("li",[v._v("static\n"),l("ul",[l("li",[v._v("使用对象：类、变量、方法、初始化函数（注意："),l("strong",[v._v("修饰类时只能修饰内部类")]),v._v("）")])])]),v._v(" "),l("li",[v._v("final\n"),l("ul",[l("li",[v._v("使用对象：类、变量、方法")])])]),v._v(" "),l("li",[v._v("transient\n"),l("ul",[l("li",[v._v("告诉编译器，在类对象序列化的时候，此变量不需要持久保存")])])]),v._v(" "),l("li",[v._v("volatile\n"),l("ul",[l("li",[v._v("指出可能有多个线程修改此变量，要求编译器优化以保证对此变量的修改\n能够被正确的处理")])])]),v._v(" "),l("li",[v._v("native\n"),l("ul",[l("li",[v._v("用该修饰符定义的方法在类中没有实现，而大多数情况下该方法的实现\n是用C、C++编写的。")])])]),v._v(" "),l("li",[v._v("synchronized\n"),l("ul",[l("li",[v._v("修饰方法，多线程的支持")])])])]),v._v(" "),l("h2",{attrs:{id:"外部类和内部类"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#外部类和内部类"}},[v._v("#")]),v._v(" 外部类和内部类")]),v._v(" "),l("ul",[l("li",[v._v("外部类是相对于内部类而言的，内部类是定义在类里面的类。")])]),v._v(" "),l("h2",{attrs:{id:"外部类的修饰符有"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#外部类的修饰符有"}},[v._v("#")]),v._v(" #外部类的修饰符有：")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("default（缺省，不写）")]),v._v(" "),l("ul",[l("li",[v._v("类定义时前面未加任何修饰符，表示同一个包中可见。")])])]),v._v(" "),l("li",[l("p",[v._v("public")]),v._v(" "),l("ul",[l("li",[v._v("修饰类时表示该类能被项目中所有类可见")])])]),v._v(" "),l("li",[l("p",[v._v("abstract")]),v._v(" "),l("ul",[l("li",[v._v("表示是抽象类")])])]),v._v(" "),l("li",[l("p",[v._v("final")]),v._v(" "),l("ul",[l("li",[v._v("表示类不可以被继承")])])]),v._v(" "),l("li",[l("p",[v._v("scrictpf")]),v._v(" "),l("ul",[l("li",[v._v("(java关键字) 当对一个类或接口使用 strictfp 关键字时，\n该类中的所有代码，包括嵌套类型中的初始设定值和代码，\n都将严格地进行计算。严格约束意味着所有表达式的结果都必须是\nIEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示")])])])]),v._v(" "),l("h2",{attrs:{id:"内部类又分"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#内部类又分"}},[v._v("#")]),v._v(" 内部类又分")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("成员内部类")]),v._v(" "),l("ul",[l("li",[v._v("作为外部类的一个成员存在，与外部类的属性、方法并列")]),v._v(" "),l("li",[v._v("成员内部类修饰符有：\n"),l("ul",[l("li",[v._v("public：")]),v._v(" "),l("li",[v._v("protected：")]),v._v(" "),l("li",[v._v("private：private不能修饰外部类，")]),v._v(" "),l("li",[v._v("abstract：")]),v._v(" "),l("li",[v._v("final：")]),v._v(" "),l("li",[v._v("static：可以当做普通类使用，而不用先实例化一个外部类。（用他修饰后，就成了静态内部类了）")]),v._v(" "),l("li",[v._v("strictfp：（java关键字） 即 strict float point (精确浮点)。（可修饰类、接口、方法）")])])])])]),v._v(" "),l("li",[l("p",[v._v("局部内部类")]),v._v(" "),l("ul",[l("li",[v._v("局部内部类就是在类内的方法中定义的类。")]),v._v(" "),l("li",[v._v("局部类有一个优势，即对外部世界完全隐藏。即使是同一个类中其他的方法也不能访问它。")]),v._v(" "),l("li",[v._v("局部类可以访问包含它的外部类，同时也可以访问局部变量。")]),v._v(" "),l("li",[v._v("局部类不能用public或private访问说明符进行声明，他的作用域被限定在这个方法中，")])])]),v._v(" "),l("li",[l("p",[v._v("静态内部类")]),v._v(" "),l("ul",[l("li",[v._v("使用static修饰的内部类")])])]),v._v(" "),l("li",[l("p",[v._v("匿名内部类")]),v._v(" "),l("ul",[l("li",[v._v("就是没有名字的内部类")])])])]),v._v(" "),l("h2",{attrs:{id:"访问权限符与继承"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#访问权限符与继承"}},[v._v("#")]),v._v(" 访问权限符与继承")]),v._v(" "),l("ul",[l("li",[v._v("这里的访问权限修饰符指的是：修饰成员变量和方法。分两种情况：\n"),l("ul",[l("li",[l("p",[v._v("子类与父类在同一个包中")]),v._v(" "),l("ul",[l("li",[v._v("此时只有private修饰的变量和方法不能被访问。")])])]),v._v(" "),l("li",[l("p",[v._v("子类与父类不在同一个包中")]),v._v(" "),l("ul",[l("li",[v._v("此时private和default均不能被访问，protected和public可以")])])])])])]),v._v(" "),l("h2",{attrs:{id:"接口修饰符"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#接口修饰符"}},[v._v("#")]),v._v(" 接口修饰符")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("public：所有包可见")])]),v._v(" "),l("li",[l("p",[v._v("default：（缺省）同一个包中可见")])]),v._v(" "),l("li",[l("p",[v._v("strictfp:（java关键字） 即 strict float point (精确浮点)。")])]),v._v(" "),l("li",[l("p",[v._v("接口的变量总是需要定义成：public static final 类型 名称，但可以不用写的这么复杂，默认就是public static final")])]),v._v(" "),l("li",[l("p",[v._v("接口的方法只能使用public、abstract修饰。")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);