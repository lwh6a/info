# JVM内存模型

## JVM也是一个操作系统

1. class文件到执行中间的流程

1. class文件中的为数字，字节码框架的asc码按一定规律组成，首先装载class文件，然后把class文件；
2. 通过类似javap工具的code转指令的程序/过程转为JVM指令，即load、store等；
3. JVM通过调用本地操作系统api执行指令，如load、store等；

2. JVM虚拟机整体结构
   1. 类装载子系统
   2. 运行时数据去（内存模型）
   3. 字节码执行引擎

## 二、JVM内存模型（运行时数据去）

1. 本地方法栈：公有native方法入栈

2. 栈 ：私有，栈里面放的方法，每调用一个方法就压入，没个方法对应一个栈帧

3. 堆：公有，分为年轻代（1/3）和老年代（2/3），年轻代又分为eden（8/10）和s0（1/10）、s1（1/10）；

4. 方法区（类元信息、常量池、静态变量）：公有

5. 程序计数器：线程独有，记录Jvm指令执行的行号，字节码执行引擎会随着执行代码每一行去修改程序计数器；

   ###### 栈帧：

   1. 局部变量表：方法中的对象，入this、方法中的局部变量
   2. 操作数栈：栈结构，栈帧方法执行的时候，每个Jvm指令的操作压入操作数栈，是对应JVM的指令的数据存放；
   3. 动态链接：把除静态方法之外的局部方法所引用的变量，把他们的符号引用换成直接地址引用，地址值，把直接引用代码放入动态链接；
   4. 方法出口：每个方法执行完，该执行哪行代码，执行哪个方法了，是放在这里；

   ###### 对空间：

   1. eden：
      1. 字节码执行引擎去开启一个线程进行minor gc；
      2. Gc方式是从GcRoot对象开始找，GcRoot包括线程本地变量、静态变量、本地方法、本地方法栈的变量等；
      3. 当进行完minor gc之后还存活的对象会放到server区
   2. s0、s1：s0和s1是每次只会放一个，eden和s0存活的对象都会放到s1，下次eden和s1还存活的对象会放到s0；
   3. 老年代：当s0和s1种分代年龄超过15之后会进入老年代；

   ###### STW：stop the world

   	1. 指停止所有客户线程，对用户体验影响较大；
    	2. 存在原因：为了更安全的回收垃圾对象，Gc过程中如果不停止会发生在查找垃圾对象的时候，遍历过的对象会突然变成垃圾对象，导致Gc标记白做，增加复杂性；

# 三、JVM参数

1. 方法区默认初试21m，会随着full gc改变，如果在full gc之后释放了大量空间，就降低该值，如果释放很少，就提高该值，所以推荐设置：
   1. -XX: MaxMetaspaceSize: 设置元空间最大值，默认-1，不限制，物理大小；
   2. -XX: MetaspaceSize: 设置元空间初始空间大小，默认21m；
   3. 8G一般设置为256M；
2. 堆空间oom情况：对象创建太多，无法回收；
3. 栈空间oom情况：递归调用，方法调用太多；
4. 永久代oom情况：动态代理类太对，类信息超过设置；